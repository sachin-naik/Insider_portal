<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <a class="navbar-brand">Autocomplete</a>
        </div>
    </div>
</nav>

<div class="text-justify">
    <p>The autocomplete is a normal text input enhanced by a panel of suggested options. You can read more about autocompletes in the Material Design spec.</p>
    <span>Simple autocomplete</span>
    <p>Start by adding a regular mdInput to the page. Let's assume you're using the formControl directive from the @angular/forms module to track the value of the input.</p>

    <md-card>
        <md-card-title> Auto Complete
            <button md-mini-fab class="pull-right"><md-icon>code</md-icon></button>
        </md-card-title>
        <md-card-content>
            <!--<md-input-container>
                <input mdInput placeholder="State" [mdAutocomplete]="auto" [formControl]="stateCtrl">
            </md-input-container>

            <md-autocomplete #auto="mdAutocomplete">
                <md-option *ngFor="let state of filteredStates | async" [value]="state">
                    {{ state }}
                </md-option>
            </md-autocomplete>-->
        </md-card-content>
    </md-card>

    <span>Adding a custom filter</span>
    <p>At this point, the autocomplete panel should be toggleable on focus and options should be selectable. But if we want our options to filter when we type, we need to add a custom filter.</p>
    <p>You can filter the options in any way you like based on the text input*. Here we will perform a simple string test on the option value to see if it matches the input value, starting from the option's first letter. We already have access to the built-in
        valueChanges observable on the FormControl, so we can simply map the text input's values to the suggested options by passing them through this filter. The resulting observable (filteredOptions) can be added to the template in place of the options
        property using the async pipe.</p>
    <p>Below we are also priming our value change stream with null so that the options are filtered by that value on init (before there are any value changes).</p>
    <p>*For optimal accessibility, you may want to consider adding text guidance on the page to explain filter criteria. This is especially helpful for screenreader users if you're using a non-standard filter that doesn't limit matches to the beginning of
        the string.</p>
</div>